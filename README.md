<a id="top"></a>

# goit-algo2-hw-08

**Зміст**

<a href="#1"><img src="https://img.shields.io/badge/Реалізація Rate Limiter з використанням алгоритму Sliding Window для обмеження частоти повідомлень у чаті-512BD4?style=for-the-badge"/></a> <a href="#2"><img src="https://img.shields.io/badge/Реалізація Rate Limiter з використанням алгоритму Throttling для обмеження частоти повідомлень у чаті-ECD53F?style=for-the-badge"/></a>

---

<a id="1"></a>

## Реалізація Rate Limiter з використанням алгоритму Sliding Window для обмеження частоти повідомлень у чаті

У чат-системі реалізовано механізм обмеження частоти повідомлень від користувачів для запобігання спаму. Реалізація використовує алгоритм Sliding Window для точного контролю часових інтервалів, який дозволяє відстежувати кількість повідомлень у заданому часовому вікні й обмежувати користувачів у надсиланні повідомлень, якщо ліміт перевищено.

Для реалізації rate limiter з використанням алгоритму Sliding Window зберігаються мітки часу кожного запиту від користувача. Алгоритм дозволяє перевіряти, скільки запитів було зроблено в межах визначеного часового вікна, і відхиляти нові, якщо ліміт перевищено. Цей підхід є точнішим за простий Fixed Window, оскільки він не має "сплесків" запитів на початку нового вікна.

**Принцип роботи:**

1. **Перші 5 повідомлень (ID 1-5):** Кожен користувач (```2, 3, 4, 5, 1```) відправляє своє перше повідомлення. Оскільки ліміт (1 повідомлення на 10 секунд) ще не перевищено, усі вони дозволені (```✓```).

2. **Наступні 5 повідомлень (ID 6-10):** Користувачі знову намагаються відправити повідомлення. Їхні попередні повідомлення були відправлені менш ніж 10 секунд тому, тому нові запити відхиляються (```×```). Метод ```time_until_next_allowed``` показує, скільки часу залишилося до кінця вікна.

3. **Після очікування:** Після 4-секундної паузи час від перших повідомлень збільшився. Користувачі знову намагаються відправити повідомлення.

- **Повідомлення 11-14:** Вікно ще не повністю очистилося. Наприклад, для користувача ```2``` його перший запит був 4+ секунди тому, тому до 10 секунд йому залишилося чекати ```10 - (4 + затримка)```.

- **Повідомлення 15-19:** Час, що минув, перевищив 10 секунд від моменту першого запиту для кожного користувача. Це призводить до очищення їхньої історії, що дозволяє відправлення нових повідомлень.

- **Повідомлення 20:** Користувач ```1``` щойно відправив повідомлення, тому його наступний запит відхиляється.

**Очікуваний результат**
Після запуску ви побачите у терміналі вивід, який імітує роботу **Rate Limiter**, згідно з очікуваним результатом у завданні. Це підтвердить, що код працює коректно.

```Bash
=== Симуляція потоку повідомлень ===
Повідомлення  1 | Користувач 2 | ✓
Повідомлення  2 | Користувач 3 | ✓
Повідомлення  3 | Користувач 4 | ✓
Повідомлення  4 | Користувач 5 | ✓
Повідомлення  5 | Користувач 1 | ✓
Повідомлення  6 | Користувач 2 | × (очікування 7.5с)
Повідомлення  7 | Користувач 3 | × (очікування 7.9с)
Повідомлення  8 | Користувач 4 | × (очікування 7.5с)
Повідомлення  9 | Користувач 5 | × (очікування 7.0с)
Повідомлення 10 | Користувач 1 | × (очікування 6.9с)

Очікуємо 4 секунди...

=== Нова серія повідомлень після очікування ===
Повідомлення 11 | Користувач 2 | × (очікування 0.7с)
Повідомлення 12 | Користувач 3 | × (очікування 1.2с)
Повідомлення 13 | Користувач 4 | × (очікування 1.5с)
Повідомлення 14 | Користувач 5 | × (очікування 1.0с)
Повідомлення 15 | Користувач 1 | × (очікування 1.1с)
Повідомлення 16 | Користувач 2 | ✓
Повідомлення 17 | Користувач 3 | ✓
Повідомлення 18 | Користувач 4 | ✓
Повідомлення 19 | Користувач 5 | ✓
Повідомлення 20 | Користувач 1 | ✓
```

[Top :arrow_double_up:](#top)

---

<a id="2"></a>

## Реалізація Rate Limiter з використанням алгоритму Throttling для обмеження частоти повідомлень у чаті

У чат-системі реалізовано механізм обмеження частоти повідомлень від користувачів для запобігання спаму. Реалізація використовує алгоритм **Throttling** для контролю часових інтервалів між повідомленнями, який забезпечує фіксований інтервал очікування між повідомленнями користувача й обмежує частоту відправки, якщо цього інтервалу не дотримано.

**Принцип роботи**

Реалізований клас ```ThrottlingRateLimiter``` використовує алгоритм **Throttling** для обмеження частоти повідомлень. Цей алгоритм, на відміну від **Token Bucket** або **Leaky Bucket**, є відносно простим і прямолінійним: він забезпечує фіксований інтервал між дозволеними подіями.

- **Конструктор** ```__init__```: Ініціалізує клас з мінімальним інтервалом ```min_interval``` та словником ```last_message_time```, де зберігається час останнього успішного повідомлення для кожного користувача. Ключ — це ```user_id```, а значення — ```timestamp``` (момент часу), коли користувач востаннє відправив повідомлення.

- **Метод** ```can_send_message```: Перевіряє, чи пройшло достатньо часу з моменту останнього повідомлення користувача. Якщо користувач відправляє повідомлення вперше, його ```user_id``` відсутній у словнику, і метод повертає ```True```. В іншому випадку він порівнює поточний час з часом останнього повідомлення.

- **Метод** ```record_message```: Цей метод є основною точкою входу для відправки повідомлення. Він спочатку викликає ```can_send_message```. Якщо відправка дозволена, він оновлює час останнього повідомлення у словнику ```last_message_time``` на поточний момент ```time.time()```.

- **Метод** ```time_until_next_allowed```: Обчислює, скільки часу (в секундах) залишилося до того, як користувач зможе відправити наступне повідомлення. Це допомагає клієнтським застосункам відображати таймер очікування.

**Тестування та очікуваний результат**
Тестова функція ```test_throttling_limiter()``` симулює потік повідомлень від п'яти користувачів.

- **Перша серія повідомлень:** Перші п'ять повідомлень від різних користувачів (1-5) будуть дозволені, оскільки вони відправляють повідомлення вперше.

- **Друга серія повідомлень (після затримок):** Наступні п'ять повідомлень (6-10) будуть заборонені. Оскільки вони відправляються від тих самих користувачів із невеликою затримкою (```random.uniform(0.1, 1.0)```), вони не задовольняють умову ```min_interval``` (10 секунд). Метод ```time_until_next_allowed``` показуватиме час, що залишився до 10-секундного ліміту.

- **Третя серія повідомлень (після 10-секундної паузи):** Після вимушеної 10-секундної паузи, перші кілька повідомлень (11-13) можуть бути заборонені, оскільки вони можуть бути відправлені раніше, ніж спливе 10-секундний інтервал. Однак, наступні повідомлення (14-18) будуть дозволені, оскільки ліміт у 10 секунд уже буде досягнутий. Останні повідомлення (19-20) знову будуть заборонені, оскільки вони будуть надіслані раніше, ніж через 10 секунд після дозволених повідомлень.

Результат виконання тесту буде подібний до очікуваного виведення, демонструючи, як **Throttling** запобігає спаму, "дроселюючи" надто часті запити від одного й того самого користувача.

Після запуску ви побачите у терміналі виведення, яке демонструє роботу ```ThrottlingRateLimiter```.

```Bash
=== Симуляція потоку повідомлень (Throttling) ===
Повідомлення  1 | Користувач 2 | ✓
Повідомлення  2 | Користувач 3 | ✓
Повідомлення  3 | Користувач 4 | ✓
Повідомлення  4 | Користувач 5 | ✓
Повідомлення  5 | Користувач 1 | ✓
Повідомлення  6 | Користувач 2 | × (очікування 7.9с)
Повідомлення  7 | Користувач 3 | × (очікування 8.0с)
Повідомлення  8 | Користувач 4 | × (очікування 7.7с)
Повідомлення  9 | Користувач 5 | × (очікування 7.5с)
Повідомлення 10 | Користувач 1 | × (очікування 7.7с)

Очікуємо 10 секунд...

=== Нова серія повідомлень після очікування ===
Повідомлення 11 | Користувач 2 | ✓
Повідомлення 12 | Користувач 3 | ✓
Повідомлення 13 | Користувач 4 | ✓
Повідомлення 14 | Користувач 5 | ✓
Повідомлення 15 | Користувач 1 | ✓
Повідомлення 16 | Користувач 2 | × (очікування 7.6с)
Повідомлення 17 | Користувач 3 | × (очікування 7.1с)
Повідомлення 18 | Користувач 4 | × (очікування 6.6с)
Повідомлення 19 | Користувач 5 | × (очікування 7.3с)
Повідомлення 20 | Користувач 1 | × (очікування 6.5с)
```

[Top :arrow_double_up:](#top)